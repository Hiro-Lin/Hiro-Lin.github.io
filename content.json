{"meta":{"title":"Hexo","subtitle":"","description":"","author":"林多鱼","url":"https://hiro-lin.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2023-02-10T18:07:33.978Z","updated":"2023-02-07T14:45:20.829Z","comments":false,"path":"/404.html","permalink":"https://hiro-lin.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2023-02-10T18:07:33.978Z","updated":"2023-02-07T14:45:00.509Z","comments":false,"path":"about/index.html","permalink":"https://hiro-lin.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2023-02-10T18:07:33.978Z","updated":"2023-02-07T14:45:31.810Z","comments":false,"path":"categories/index.html","permalink":"https://hiro-lin.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2023-02-10T18:07:33.978Z","updated":"2023-02-07T07:52:58.807Z","comments":true,"path":"links/index.html","permalink":"https://hiro-lin.github.io/links/index.html","excerpt":"","text":"Name: link: http://example.com avatar: http://example.com/avatar.png desc: “这是一个描述”"},{"title":"项目","date":"2023-02-10T18:07:33.978Z","updated":"2023-02-07T13:39:52.113Z","comments":false,"path":"repository/index.html","permalink":"https://hiro-lin.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2023-02-10T18:07:33.978Z","updated":"2023-02-07T14:45:53.770Z","comments":false,"path":"tags/index.html","permalink":"https://hiro-lin.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"lua table 结构","slug":"lua-table-结构","date":"2023-03-07T14:15:21.000Z","updated":"2023-03-07T14:16:17.187Z","comments":true,"path":"/2023/03/07/lua-table-结构/","link":"","permalink":"https://hiro-lin.github.io/2023/03/07/lua-table-%E7%BB%93%E6%9E%84/","excerpt":"","text":"基本用法1234567891011121314151617181920212223242526272829303132333435363738-- 初始化表mytable = &#123;&#125;-- 指定值mytable[1] = &quot;lua&quot;-- 移除引用mytable = nil-- lua 垃圾回收会释放内存- 简单的 tablemytable = &#123;&#125;print(&quot;mytable 的类型是 &quot;,type(mytable))mytable[1]= &quot;Lua&quot;mytable[&quot;wow&quot;] = &quot;修改前&quot;print(&quot;mytable 索引为 1 的元素是 &quot;, mytable[1])print(&quot;mytable 索引为 wow 的元素是 &quot;, mytable[&quot;wow&quot;])-- alternatetable和mytable的是指同一个 tablealternatetable = mytableprint(&quot;alternatetable 索引为 1 的元素是 &quot;, alternatetable[1])print(&quot;alternatetable 索引为 wow 的元素是 &quot;, alternatetable[&quot;wow&quot;])alternatetable[&quot;wow&quot;] = &quot;修改后&quot;print(&quot;mytable 索引为 wow 的元素是 &quot;, mytable[&quot;wow&quot;])-- 释放变量alternatetable = nilprint(&quot;alternatetable 是 &quot;, alternatetable)-- mytable 仍然可以访问print(&quot;mytable 索引为 wow 的元素是 &quot;, mytable[&quot;wow&quot;])mytable = nilprint(&quot;mytable 是 &quot;, mytable) Table 操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748table.concat(table[,sep[,start[,end]]])-- concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。fruits = &#123;&quot;banana&quot;,&quot;orange&quot;,&quot;apple&quot;&#125;-- 返回 table 连接后的字符串print(&quot;连接后的字符串 &quot;,table.concat(fruits))-- 指定连接字符print(&quot;连接后的字符串 &quot;,table.concat(fruits,&quot;, &quot;))-- 指定索引来连接 tableprint(&quot;连接后的字符串 &quot;,table.concat(fruits,&quot;, &quot;, 2,3))table.insert (table, [pos,] value)-- 在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾.table.remove (table [, pos])-- 返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从最后一个元素删起。fruits = &#123;&quot;banana&quot;,&quot;orange&quot;,&quot;apple&quot;&#125;-- 在末尾插入table.insert(fruits,&quot;mango&quot;)print(&quot;索引为 4 的元素为 &quot;,fruits[4])-- 在索引为 2 的键处插入table.insert(fruits,2,&quot;grapes&quot;)print(&quot;索引为 2 的元素为 &quot;,fruits[2])print(&quot;最后一个元素为 &quot;,fruits[5])table.remove(fruits)print(&quot;移除后最后一个元素为 &quot;,fruits[5])table.sort (table [, comp])-- 对给定的table进行升序排序。fruits = &#123;&quot;banana&quot;,&quot;orange&quot;,&quot;apple&quot;,&quot;grapes&quot;&#125;print(&quot;排序前&quot;)for k,v in ipairs(fruits) do print(k,v)endtable.sort(fruits)print(&quot;排序后&quot;)for k,v in ipairs(fruits) do print(k,v)end Table 遍历数组类型的 table 可以通过 ipairs 来遍历，而字典类型或者混合类型只能通过 pairs 遍历。 注意事项当我们获取 table 的长度的时候无论是使用 # 还是 table.getn 其都会在索引中断的地方停止计数，而导致无法正确取得 table 的长度。 &amp;#x20;# 获取 table 长度时，只能获取到 table 数组结构中的长度，不能获取到 table 字典类型的长度。 table 数组中存在 nil 值时，也会影响 # 来获取其长度。 可以使用以下方法来代替： 1234567function table_leng(t) local leng=0 for k, v in pairs(t) do leng=leng+1 end return leng;end","categories":[],"tags":[{"name":"lua","slug":"lua","permalink":"https://hiro-lin.github.io/tags/lua/"}]},{"title":"go常见面试题","slug":"go常见面试题","date":"2023-02-10T18:07:32.000Z","updated":"2023-02-11T07:49:25.385Z","comments":true,"path":"/2023/02/11/go常见面试题/","link":"","permalink":"https://hiro-lin.github.io/2023/02/11/go%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"面试题1基础语法01 &#x3D; 和 :&#x3D; 的区别？ &#x3D;是赋值变量，:&#x3D;是定义变量。 02 指针的作用 一个指针可以指向任意变量的地址，它所指向的地址在32位或64位机器上分别固定占4或8个字节。指针的作用有： 获取变量的值 123456import fmtfunc main()&#123; a := 1 p := &amp;a//取址&amp; fmt.Printf(&quot;%d\\n&quot;, *p);//取值*&#125; 改变变量的值 1234// 交换函数func swap(a, b *int) &#123; *a, *b = *b, *a&#125; 用指针替代值传入函数，比如类的接收器就是这样的。 123type A struct&#123;&#125;​func (a *A) fun()&#123;&#125; 03 Go 允许多个返回值吗？ 可以。通常函数除了一般返回值还会返回一个error。 04 Go 有异常类型吗？ 有。Go用error类型代替try…catch语句，这样可以节省资源。同时增加代码可读性： 12345_, err := funcDemo()if err != nil &#123; fmt.Println(err) return&#125; 也可以用errors.New()来定义自己的异常。errors.Error()会返回异常的字符串表示。只要实现error接口就可以定义自己的异常， 123456789101112type errorString struct &#123; s string&#125;​func (e *errorString) Error() string &#123; return e.s&#125;​// 多一个函数当作构造函数func New(text string) error &#123; return &amp;errorString&#123;text&#125;&#125; 05 什么是协程（Goroutine） 协程是用户态轻量级线程，它是线程调度的基本单位。通常在函数前加上go关键字就能实现并发。一个Goroutine会以一个很小的栈启动2KB或4KB，当遇到栈空间不足时，栈会自动伸缩， 因此可以轻易实现成千上万个goroutine同时启动。 06 ❤ 如何高效地拼接字符串 拼接字符串的方式有：+ , fmt.Sprintf , strings.Builder, bytes.Buffer, strings.Join 1 “+” 使用+操作符进行拼接时，会对字符串进行遍历，计算并开辟一个新的空间来存储原来的两个字符串。 2 fmt.Sprintf 由于采用了接口参数，必须要用反射获取值，因此有性能损耗。 3 strings.Builder： 用WriteString()进行拼接，内部实现是指针+切片，同时String()返回拼接后的字符串，它是直接把[]byte转换为string，从而避免变量拷贝。 4 bytes.Buffer bytes.Buffer是一个一个缓冲byte类型的缓冲器，这个缓冲器里存放着都是byte， bytes.buffer底层也是一个[]byte切片。 5 strings.join strings.join也是基于strings.builder来实现的,并且可以自定义分隔符，在join方法内调用了b.Grow(n)方法，这个是进行初步的容量分配，而前面计算的n的长度就是我们要拼接的slice的长度，因为我们传入切片长度固定，所以提前进行容量分配可以减少内存分配，很高效。 性能比较： strings.Join ≈ strings.Builder &gt; bytes.Buffer &gt; “+” &gt; fmt.Sprintf 5种拼接方法的实例代码 123456789101112131415161718192021func main()&#123; a := []string&#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#125; //方式1：+ ret := a[0] + a[1] + a[2] //方式2：fmt.Sprintf ret := fmt.Sprintf(&quot;%s%s%s&quot;, a[0],a[1],a[2]) //方式3：strings.Builder var sb strings.Builder sb.WriteString(a[0]) sb.WriteString(a[1]) sb.WriteString(a[2]) ret := sb.String() //方式4：bytes.Buffer buf := new(bytes.Buffer) buf.Write(a[0]) buf.Write(a[1]) buf.Write(a[2]) ret := buf.String() //方式5：strings.Join ret := strings.Join(a,&quot;&quot;)&#125; 07 什么是 rune 类型 ASCII 码只需要 7 bit 就可以完整地表示，但只能表示英文字母在内的128个字符，为了表示世界上大部分的文字系统，发明了 Unicode， 它是ASCII的超集，包含世界上书写系统中存在的所有字符，并为每个代码分配一个标准编号（称为Unicode CodePoint），在 Go 语言中称之为 rune，是 int32 类型的别名。 Go 语言中，字符串的底层表示是 byte (8 bit) 序列，而非 rune (32 bit) 序列。 12345sample := &quot;我爱GO&quot;runeSamp := []rune(sample)runeSamp[0] = &#x27;你&#x27;fmt.Println(string(runeSamp)) // &quot;你爱GO&quot;fmt.Println(len(runeSamp)) // 4 08 如何判断 map 中是否包含某个 key ？ 123456var sample map[int]intif _, ok := sample[10]; ok &#123;&#125; else &#123;&#125; 09 Go 支持默认参数或可选参数吗？ 不支持。但是可以利用结构体参数，或者…传入参数切片数组。 12345678// 这个函数可以传入任意数量的整型参数func sum(nums ...int) &#123; total := 0 for _, num := range nums &#123; total += num &#125; fmt.Println(total)&#125; 10 defer 的执行顺序 defer执行顺序和调用顺序相反，类似于栈后进先出(LIFO)。 defer在return之后执行，但在函数退出之前，defer可以修改返回值。下面是一个例子： 123456789101112131415161718func test() int &#123; i := 0 defer func() &#123; fmt.Println(&quot;defer1&quot;) &#125;() defer func() &#123; i += 1 fmt.Println(&quot;defer2&quot;) &#125;() return i&#125;func main() &#123; fmt.Println(&quot;return&quot;, test())&#125;// defer2// defer1// return 0 上面这个例子中，test返回值并没有修改，这是由于Go的返回机制决定的，执行Return语句后，Go会创建一个临时变量保存返回值。如果是有名返回（也就是指明返回值func test() (i int)） 1234567891011121314func test() (i int) &#123; i = 0 defer func() &#123; i += 1 fmt.Println(&quot;defer2&quot;) &#125;() return i&#125;func main() &#123; fmt.Println(&quot;return&quot;, test())&#125;// defer2// return 1 这个例子中，返回值被修改了。对于有名返回值的函数，执行 return 语句时，并不会再创建临时变量保存，因此，defer 语句修改了 i，即对返回值产生了影响。 11 如何交换 2 个变量的值？ 对于变量而言a,b &#x3D; b,a； 对于指针而言*a,*b &#x3D; *b, *a 12 Go 语言 tag 的用处？ tag可以为结构体成员提供属性。常见的： json序列化或反序列化时字段的名称db: sqlx模块中对应的数据库字段名form: gin框架中对应的前端的数据字段名binding: 搭配 form 使用, 默认如果没查找到结构体中的某个字段则不报错值为空, binding为 required 代表没找到返回错误给前端 13 如何获取一个结构体的所有tag？ 利用反射： 1234567891011121314import reflecttype Author struct &#123; Name int `json:Name` Publications []string `json:Publication,omitempty`&#125;func main() &#123; t := reflect.TypeOf(Author&#123;&#125;) for i := 0; i &lt; t.NumField(); i++ &#123; name := t.Field(i).Name s, _ := t.FieldByName(name) fmt.Println(name, s.Tag) &#125;&#125; 上述例子中，reflect.TypeOf方法获取对象的类型，之后NumField()获取结构体成员的数量。 通过Field(i)获取第i个成员的名字。 再通过其Tag 方法获得标签。 14 如何判断 2 个字符串切片（slice) 是相等的？ reflect.DeepEqual() ， 但反射非常影响性能。 15 结构体打印时，%v 和 %+v 的区别 %v输出结构体各成员的值； %+v输出结构体各成员的名称和值； %#v输出结构体名称和结构体各成员的名称和值 16 Go 语言中如何表示枚举值(enums)？ 在常量中用iota可以表示枚举。iota从0开始。 123456789const ( B = 1 &lt;&lt; (10 * iota) KiB MiB GiB TiB PiB EiB) 17 空 struct{} 的用途 用map模拟一个set，那么就要把值置为struct{}，struct{}本身不占任何空间，可以避免任何多余的内存分配。 12345678910111213type Set map[string]struct&#123;&#125;func main() &#123; set := make(Set) for _, item := range []string&#123;&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;&#125; &#123; set[item] = struct&#123;&#125;&#123;&#125; &#125; fmt.Println(len(set)) // 3 if _, ok := set[&quot;A&quot;]; ok &#123; fmt.Println(&quot;A exists&quot;) // A exists &#125;&#125; 有时候给通道发送一个空结构体,channel&lt;-struct{}{}，也是节省了空间。 123456789func main() &#123; ch := make(chan struct&#123;&#125;, 1) go func() &#123; &lt;-ch // do something &#125;() ch &lt;- struct&#123;&#125;&#123;&#125; // ...&#125; 仅有方法的结构体 1type Lamp struct&#123;&#125; 18 go里面的int和int32是同一个概念吗？ 不是一个概念！千万不能混淆。go语言中的int的大小是和操作系统位数相关的，如果是32位操作系统，int类型的大小就是4字节。如果是64位操作系统，int类型的大小就是8个字节。除此之外uint也与操作系统有关。 int8占1个字节，int16占2个字节，int32占4个字节，int64占8个字节。 实现原理01 init() 函数是什么时候执行的？ 简答： 在main函数之前执行。 详细：init()函数是go初始化的一部分，由runtime初始化每个导入的包，初始化不是按照从上到下的导入顺序，而是按照解析的依赖关系，没有依赖的包最先初始化。 每个包首先初始化包作用域的常量和变量（常量优先于变量），然后执行包的init()函数。同一个包，甚至是同一个源文件可以有多个init()函数。init()函数没有入参和返回值，不能被其他函数调用，同一个包内多个init()函数的执行顺序不作保证。 执行顺序：import –&gt; const –&gt; var –&gt;init()–&gt;main() 一个文件可以有多个init()函数！ 02 ❤如何知道一个对象是分配在栈上还是堆上？ Go和C++不同，Go局部变量会进行逃逸分析。如果变量离开作用域后没有被引用，则优先分配到栈上，否则分配到堆上。那么如何判断是否发生了逃逸呢？ go build -gcflags ‘-m -m -l’ xxx.go. 关于逃逸的可能情况：变量大小不确定，变量类型不确定，变量分配的内存超过用户栈最大值，暴露给了外部指针。 03 2 个 interface 可以比较吗 ？ Go 语言中，interface 的内部实现包含了 2 个字段，类型 T 和 值 V，interface 可以使用 &#x3D;&#x3D; 或 !&#x3D; 比较。2 个 interface 相等有以下 2 种情况 两个 interface 均等于 nil（此时 V 和 T 都处于 unset 状态）类型 T 相同，且对应的值 V 相等。看下面的例子： 123456789101112type Stu struct &#123; Name string&#125;type StuInt interface&#123;&#125;func main() &#123; var stu1, stu2 StuInt = &amp;Stu&#123;&quot;Tom&quot;&#125;, &amp;Stu&#123;&quot;Tom&quot;&#125; var stu3, stu4 StuInt = Stu&#123;&quot;Tom&quot;&#125;, Stu&#123;&quot;Tom&quot;&#125; fmt.Println(stu1 == stu2) // false fmt.Println(stu3 == stu4) // true&#125; stu1 和 stu2 对应的类型是 *Stu，值是 Stu 结构体的地址，两个地址不同，因此结果为 false。stu3 和 stu4 对应的类型是 Stu，值是 Stu 结构体，且各字段相等，因此结果为 true。 04 2 个 nil 可能不相等吗？ 可能不等。interface在运行时绑定值，只有值为nil接口值才为nil，但是与指针的nil不相等。举个例子： 12345var p *int = nilvar i interface&#123;&#125; = nilif(p == i)&#123; fmt.Println(&quot;Equal&quot;)&#125; 两者并不相同。总结：两个nil只有在类型相同时才相等。 05 ❤简述 Go 语言GC(垃圾回收)的工作原理 垃圾回收机制是Go一大特(nan)色(dian)。Go1.3采用标记清除法， Go1.5采用三色标记法，Go1.8采用三色标记法+混合写屏障。 标记清除法 分为两个阶段：标记和清除 标记阶段：从根对象出发寻找并标记所有存活的对象。 清除阶段：遍历堆中的对象，回收未标记的对象，并加入空闲链表。 缺点是需要暂停程序STW。 三色标记法： 将对象标记为白色，灰色或黑色。 白色：不确定对象（默认色）；黑色：存活对象。灰色：存活对象，子对象待处理。 标记开始时，先将所有对象加入白色集合（需要STW）。首先将根对象标记为灰色，然后将一个对象从灰色集合取出，遍历其子对象，放入灰色集合。同时将取出的对象放入黑色集合，直到灰色集合为空。最后的白色集合对象就是需要清理的对象。 这种方法有一个缺陷，如果对象的引用被用户修改了，那么之前的标记就无效了。因此Go采用了写屏障技术，当对象新增或者更新会将其着色为灰色。 一次完整的GC分为四个阶段： 准备标记（需要STW），开启写屏障。开始标记标记结束（STW），关闭写屏障清理（并发）基于插入写屏障和删除写屏障在结束时需要STW来重新扫描栈，带来性能瓶颈。混合写屏障分为以下四步： GC开始时，将栈上的全部对象标记为黑色（不需要二次扫描，无需STW）；GC期间，任何栈上创建的新对象均为黑色被删除引用的对象标记为灰色被添加引用的对象标记为灰色总而言之就是确保黑色对象不能引用白色对象，这个改进直接使得GC时间从 2s降低到2us。 06 函数返回局部变量的指针是否安全？ 这一点和C++不同，在Go里面返回局部变量的指针是安全的。因为Go会进行逃逸分析，如果发现局部变量的作用域超过该函数则会把指针分配到堆区，避免内存泄漏。 *07 非接口的任意类型 T() 都能够调用 T 的方法吗？反过来呢？ 一个T类型的值可以调用*T类型声明的方法，当且仅当T是可寻址的。 反之：*T 可以调用T()的方法，因为指针可以解引用。 08 go slice是怎么扩容的？ Go &lt;&#x3D; 1.17 如果当前容量小于1024，则判断所需容量是否大于原来容量2倍，如果大于，当前容量加上所需容量；否则当前容量乘2。 如果当前容量大于1024，则每次按照1.25倍速度递增容量，也就是每次加上cap&#x2F;4。 Go1.18之后，引入了新的扩容规则：浅谈 Go 1.18.1的切片扩容机制 并发编程01 ❤无缓冲的 channel 和有缓冲的 channel 的区别？ （这个问题笔者也纠结了很久，直到看到一篇文章，阻塞与否是分别针对发送接收方而言的，才茅塞顿开） 对于无缓冲区channel： 发送的数据如果没有被接收方接收，那么发送方阻塞；如果一直接收不到发送方的数据，接收方阻塞； 有缓冲的channel： 发送方在缓冲区满的时候阻塞，接收方不阻塞；接收方在缓冲区为空的时候阻塞，发送方不阻塞。 可以类比生产者与消费者问题。 02 为什么有协程泄露(Goroutine Leak)？ 协程泄漏是指协程创建之后没有得到释放。主要原因有： 缺少接收器，导致发送阻塞缺少发送器，导致接收阻塞死锁。多个协程由于竞争资源导致死锁。创建协程的没有回收。 03 Go 可以限制运行时操作系统线程的数量吗？ 常见的goroutine操作函数有哪些？ 可以，使用runtime.GOMAXPROCS(num int)可以设置线程数目。该值默认为CPU逻辑核数，如果设的太大，会引起频繁的线程切换，降低性能。 runtime.Gosched()，用于让出CPU时间片，让出当前goroutine的执行权限，调度器安排其它等待的任务运行，并在下次某个时候从该位置恢复执行。runtime.Goexit()，调用此函数会立即使当前的goroutine的运行终止（终止协程），而其它的goroutine并不会受此影响。runtime.Goexit在终止当前goroutine前会先执行此goroutine的还未执行的defer语句。请注意千万别在主函数调用runtime.Goexit，因为会引发panic。 04 如何控制协程数目。 The GOMAXPROCS variable limits the number of operating system threads that can execute user-level Go code simultaneously. There is no limit to the number of threads that can be blocked in system calls on behalf of Go code; those do not count against the GOMAXPROCS limit.从官方文档的解释可以看到，GOMAXPROCS 限制的是同时执行用户态 Go 代码的操作系统线程的数量，但是对于被系统调用阻塞的线程数量是没有限制的。GOMAXPROCS 的默认值等于 CPU 的逻辑核数，同一时间，一个核只能绑定一个线程，然后运行被调度的协程。因此对于 CPU 密集型的任务，若该值过大，例如设置为 CPU 逻辑核数的 2 倍，会增加线程切换的开销，降低性能。对于 I&#x2F;O 密集型应用，适当地调大该值，可以提高 I&#x2F;O 吞吐率。 另外对于协程，可以用带缓冲区的channel来控制，下面的例子是协程数为1024的例子 1234567891011var wg sync.WaitGroupch := make(chan struct&#123;&#125;, 1024)for i:=0; i&lt;20000; i++&#123; wg.Add(1) ch&lt;-struct&#123;&#125;&#123;&#125; go func()&#123; defer wg.Done() &lt;-ch &#125;&#125;wg.Wait() 此外还可以用协程池：其原理无外乎是将上述代码中通道和协程函数解耦，并封装成单独的结构体。常见第三方协程池库，比如tunny等。 面试题评价：★★★☆☆。偏容易和基础。分为基础语法、实现原理、并发编程三个大部分，需要读者有扎实的基础。 面试题2❤new和make的区别？ new只用于分配内存，返回一个指向地址的指针。它为每个新类型分配一片内存，初始化为0且返回类型*T的内存地址，它相当于&amp;T{}make只可用于slice,map,channel的初始化,返回的是引用。 请你讲一下Go面向对象是如何实现的？ Go实现面向对象的两个关键是struct和interface。 封装：对于同一个包，对象对包内的文件可见；对不同的包，需要将对象以大写开头才是可见的。 继承：继承是编译时特征，在struct内加入所需要继承的类即可： 1234type A struct&#123;&#125;type B struct&#123; A&#125; 多态：多态是运行时特征，Go多态通过interface来实现。类型和接口是松耦合的，某个类型的实例可以赋给它所实现的任意接口类型的变量。 Go支持多重继承，就是在类型中嵌入所有必要的父类型。 uint型变量值分别为 1，2，它们相减的结果是多少？ 123var a uint = 1var b uint = 2fmt.Println(a - b) 答案，结果会溢出，如果是32位系统，结果是2^32-1，如果是64位系统，结果2^64-1. 讲一下go有没有函数在main之前执行？怎么用？ go的init函数在main函数之前执行，它有如下特点： 123func init() &#123; ...&#125; init函数非常特殊： 初始化不能采用初始化表达式初始化的变量；程序运行前执行注册实现sync.Once功能不能被其它函数调用init函数没有入口参数和返回值：每个包可以有多个init函数，每个源文件也可以有多个init函数。同一个包的init执行顺序，golang没有明确定义，编程时要注意程序不要依赖这个执行顺序。不同包的init函数按照包导入的依赖关系决定执行顺序。 下面这句代码是什么作用，为什么要定义一个空值？ 12345678910111213type GobCodec struct&#123; conn io.ReadWriteCloser buf *bufio.Writer dec *gob.Decoder enc *gob.Encoder&#125;type Codec interface &#123; io.Closer ReadHeader(*Header) error ReadBody(interface&#123;&#125;) error Write(*Header, interface&#123;&#125;) error&#125; var _ Codec &#x3D; (*GobCodec)(nil) 答：将nil转换为GobCodec类型，然后再转换为Codec接口，如果转换失败，说明GobCodec没有实现Codec接口的所有方法。 ❤golang的内存管理的原理清楚吗？简述go内存管理机制。 golang内存管理基本是参考tcmalloc来进行的。go内存管理本质上是一个内存池，只不过内部做了很多优化：自动伸缩内存池大小，合理的切割内存块。 一些基本概念： 页Page：一块8K大小的内存空间。Go向操作系统申请和释放内存都是以页为单位的。 span : 内存块，一个或多个连续的 page 组成一个 span 。如果把 page 比喻成工人， span 可看成是小队，工人被分成若干个队伍，不同的队伍干不同的活。 sizeclass : 空间规格，每个 span 都带有一个 sizeclass ，标记着该 span 中的 page 应该如何使用。使用上面的比喻，就是 sizeclass 标志着 span 是一个什么样的队伍。 object : 对象，用来存储一个变量数据内存空间，一个 span 在初始化时，会被切割成一堆等大的 object 。假设 object 的大小是 16B ， span 大小是 8K ，那么就会把 span 中的 page 就会被初始化 8K &#x2F; 16B &#x3D; 512 个 object 。所谓内存分配，就是分配一个 object 出去。 mheap 一开始go从操作系统索取一大块内存作为内存池，并放在一个叫mheap的内存池进行管理，mheap将一整块内存切割为不同的区域，并将一部分内存切割为合适的大小。 mheap.spans ：用来存储 page 和 span 信息，比如一个 span 的起始地址是多少，有几个 page，已使用了多大等等。 mheap.bitmap 存储着各个 span 中对象的标记信息，比如对象是否可回收等等。 mheap.arena_start : 将要分配给应用程序使用的空间。 mcentral 用途相同的span会以链表的形式组织在一起存放在mcentral中。这里用途用sizeclass来表示，就是该span存储哪种大小的对象。 找到合适的 span 后，会从中取一个 object 返回给上层使用。 mcache 为了提高内存并发申请效率，加入缓存层mcache。每一个mcache和处理器P对应。Go申请内存首先从P的mcache中分配，如果没有可用的span再从mcentral中获取。 ❤mutex有几种模式？ mutex有两种模式：normal 和 starvation 正常模式 所有goroutine按照FIFO的顺序进行锁获取，被唤醒的goroutine和新请求锁的goroutine同时进行锁获取，通常新请求锁的goroutine更容易获取锁(持续占有cpu)，被唤醒的goroutine则不容易获取到锁。公平性：否。 饥饿模式 所有尝试获取锁的goroutine进行等待排队，新请求锁的goroutine不会进行锁获取(禁用自旋)，而是加入队列尾部等待获取锁。公平性：是。 参考链接：Go Mutex 饥饿模式，GO 互斥锁（Mutex）原理 面试题3 ❤go如何进行调度的。GMP中状态流转。 Go里面GMP分别代表：G：goroutine，M：线程（真正在CPU上跑的），P：调度器。 GMP模型 调度器是M和G之间桥梁。 go进行调度过程： 某个线程尝试创建一个新的G，那么这个G就会被安排到这个线程的G本地队列LRQ中，如果LRQ满了，就会分配到全局队列GRQ中；尝试获取当前线程的M，如果无法获取，就会从空闲的M列表中找一个，如果空闲列表也没有，那么就创建一个M，然后绑定G与P运行。进入调度循环：找到一个合适的G执行G，完成以后退出 Go什么时候发生阻塞？阻塞时，调度器会怎么做。 用于原子、互斥量或通道操作导致goroutine阻塞，调度器将把当前阻塞的goroutine从本地运行队列LRQ换出，并重新调度其它goroutine；由于网络请求和IO导致的阻塞，Go提供了网络轮询器（Netpoller）来处理，后台用epoll等技术实现IO多路复用。其它回答： channel阻塞：当goroutine读写channel发生阻塞时，会调用gopark函数，该G脱离当前的M和P，调度器将新的G放入当前M。系统调用：当某个G由于系统调用陷入内核态，该P就会脱离当前M，此时P会更新自己的状态为Psyscall，M与G相互绑定，进行系统调用。结束以后，若该P状态还是Psyscall，则直接关联该M和G，否则使用闲置的处理器处理该G。系统监控：当某个G在P上运行的时间超过10ms时候，或者P处于Psyscall状态过长等情况就会调用retake函数，触发新的调度。主动让出：由于是协作式调度，该G会主动让出当前的P（通过GoSched），更新状态为Grunnable，该P会调度队列中的G运行。更多关于netpoller的内容可以参看：https://strikefreedom.top/go-netpoll-io-multiplexing-reactor ❤Go中GMP有哪些状态？ G的状态： _Gidle：刚刚被分配并且还没有被初始化，值为0，为创建goroutine后的默认值 _Grunnable： 没有执行代码，没有栈的所有权，存储在运行队列中，可能在某个P的本地队列或全局队列中(如上图)。 _Grunning： 正在执行代码的goroutine，拥有栈的所有权(如上图)。 _Gsyscall：正在执行系统调用，拥有栈的所有权，与P脱离，但是与某个M绑定，会在调用结束后被分配到运行队列(如上图)。 _Gwaiting：被阻塞的goroutine，阻塞在某个channel的发送或者接收队列(如上图)。 _Gdead： 当前goroutine未被使用，没有执行代码，可能有分配的栈，分布在空闲列表gFree，可能是一个刚刚初始化的goroutine，也可能是执行了goexit退出的goroutine(如上图)。 _Gcopystac：栈正在被拷贝，没有执行代码，不在运行队列上，执行权在 _Gscan ： GC 正在扫描栈空间，没有执行代码，可以与其他状态同时存在。 P的状态： _Pidle ：处理器没有运行用户代码或者调度器，被空闲队列或者改变其状态的结构持有，运行队列为空 _Prunning ：被线程 M 持有，并且正在执行用户代码或者调度器(如上图) _Psyscall：没有执行用户代码，当前线程陷入系统调用(如上图) _Pgcstop ：被线程 M 持有，当前处理器由于垃圾回收被停止 _Pdead ：当前处理器已经不被使用 M的状态： 自旋线程：处于运行状态但是没有可执行goroutine的线程，数量最多为GOMAXPROC，若是数量大于GOMAXPROC就会进入休眠。 非自旋线程：处于运行状态有可执行goroutine的线程。 GMP能不能去掉P层？会怎么样？ P层的作用 每个 P 有自己的本地队列，大幅度的减轻了对全局队列的直接依赖，所带来的效果就是锁竞争的减少。而 GM 模型的性能开销大头就是锁竞争。每个 P 相对的平衡上，在 GMP 模型中也实现了 Work Stealing 算法，如果 P 的本地队列为空，则会从全局队列或其他 P 的本地队列中窃取可运行的 G 来运行，减少空转，提高了资源利用率。参考资料：https://juejin.cn/post/6968311281220583454 如果有一个G一直占用资源怎么办？什么是work stealing算法？ 如果有个goroutine一直占用资源，那么GMP模型会从正常模式转变为饥饿模式（类似于mutex），允许其它goroutine使用work stealing抢占（禁用自旋锁）。 work stealing算法指，一个线程如果处于空闲状态，则帮其它正在忙的线程分担压力，从全局队列取一个G任务来执行，可以极大提高执行效率。 goroutine什么情况会发生内存泄漏？如何避免。 在Go中内存泄露分为暂时性内存泄露和永久性内存泄露。 暂时性内存泄露 获取长字符串中的一段导致长字符串未释放获取长slice中的一段导致长slice未释放在长slice新建slice导致泄漏string相比切片少了一个容量的cap字段，可以把string当成一个只读的切片类型。获取长string或者切片中的一段内容，由于新生成的对象和老的string或者切片共用一个内存空间，会导致老的string和切片资源暂时得不到释放，造成短暂的内存泄漏 永久性内存泄露 goroutine永久阻塞而导致泄漏time.Ticker未关闭导致泄漏不正确使用Finalizer（Go版本的析构函数）导致泄漏 Go GC有几个阶段 目前的go GC采用三色标记法和混合写屏障技术。 Go GC有四个阶段: STW，开启混合写屏障，扫描栈对象；将所有对象加入白色集合，从根对象开始，将其放入灰色集合。每次从灰色集合取出一个对象标记为黑色，然后遍历其子对象，标记为灰色，放入灰色集合；如此循环直到灰色集合为空。剩余的白色对象就是需要清理的对象。STW，关闭混合写屏障；在后台进行GC（并发）。 go竞态条件了解吗？ 所谓竞态竞争，就是当两个或以上的goroutine访问相同资源时候，对资源进行读&#x2F;写。 比如var a int &#x3D; 0，有两个协程分别对a+&#x3D;1，我们发现最后a不一定为2.这就是竞态竞争。 通常我们可以用go run -race xx.go来进行检测。 解决方法是，对临界区资源上锁，或者使用原子操作(atomics)，原子操作的开销小于上锁。 如果若干个goroutine，有一个panic会怎么做？ 有一个panic，那么剩余goroutine也会退出，程序退出。如果不想程序退出，那么必须通过调用 recover() 方法来捕获 panic 并恢复将要崩掉的程序。 参考理解：goroutine配上panic会怎样。 defer可以捕获goroutine的子goroutine吗？ 不可以。它们处于不同的调度器P中。对于子goroutine，必须通过 recover() 机制来进行恢复，然后结合日志进行打印（或者通过channel传递error），下面是一个例子： 123456789101112131415161718// 心跳函数func Ping(ctx context.Context) error &#123; ... code ... go func() &#123; defer func() &#123; if r := recover(); r != nil &#123; log.Errorc(ctx, &quot;ping panic: %v, stack: %v&quot;, r, string(debug.Stack())) &#125; &#125;() ... code ... &#125;() ... code ... return nil&#125; ❤gRPC是什么？ 基于go的远程过程调用。RPC 框架的目标就是让远程服务调用更加简单、透明，RPC 框架负责屏蔽底层的传输方式（TCP 或者 UDP）、序列化方式（XML&#x2F;Json&#x2F; 二进制）和通信细节。服务调用者可以像调用本地接口一样调用远程的服务提供者，而不需要关心底层通信细节和调用过程。 gRPC框架图 面试题4需要面试者有一定的大型项目经验经验，了解使用微服务，etcd，gin，gorm，gRPC等典型框架等模型或框架。 微服务了解吗？ 微服务是一种开发软件的架构和组织方法，其中软件由通过明确定义的 API 进行通信的小型独立服务组成。微服务架构使应用程序更易于扩展和更快地开发，从而加速创新并缩短新功能的上市时间。 微服务示意图微服务有着自主，专用，灵活性等优点。 参考资料：什么是微服务？| AWS 服务发现是怎么做的？ 主要有两种服务发现机制：客户端发现和服务端发现。 客户端发现模式：当我们使用客户端发现的时候，客户端负责决定可用服务实例的网络地址并且在集群中对请求负载均衡, 客户端访问服务登记表，也就是一个可用服务的数据库，然后客户端使用一种负载均衡算法选择一个可用的服务实例然后发起请求。该模式如下图所示： 客户端发现模式服务端发现模式：客户端通过负载均衡器向某个服务提出请求，负载均衡器查询服务注册表，并将请求转发到可用的服务实例。如同客户端发现，服务实例在服务注册表中注册或注销。 服务端发现模式 参考资料：「Chris Richardson 微服务系列」服务发现的可行方案以及实践案例 ETCD用过吗？etcd是一个高度一致的分布式键值存储，它提供了一种可靠的方式来存储需要由分布式系统或机器集群访问的数据。它可以优雅地处理网络分区期间的领导者选举，即使在领导者节点中也可以容忍机器故障。 etcd 是用Go语言编写的，它具有出色的跨平台支持，小的二进制文件和强大的社区。etcd机器之间的通信通过Raft共识算法处理。 关于文档可以参考：v3.5 docs GIN怎么做参数校验？go采用validator作参数校验。 它具有以下独特功能： 使用验证tag或自定义validator进行跨字段Field和跨结构体验证。允许切片、数组和哈希表，多维字段的任何或所有级别进行校验。能够对哈希表key和value进行验证通过在验证之前确定它的基础类型来处理类型接口。别名验证标签，允许将多个验证映射到单个标签，以便更轻松地定义结构体上的验证gin web 框架的默认验证器；参考资料：validator package - pkg.go.dev 中间件用过吗？Middleware是Web的重要组成部分，中间件（通常）是一小段代码，它们接受一个请求，对其进行处理，每个中间件只处理一件事情，完成后将其传递给另一个中间件或最终处理程序，这样就做到了程序的解耦。 Go解析Tag是怎么实现的？Go解析tag采用的是反射。 具体来说使用reflect.ValueOf方法获取其反射值，然后获取其Type属性，之后再通过Field(i)获取第i+1个field，再.Tag获得Tag。 反射实现的原理在: src/reflect/type.go中 你项目有优雅的启停吗？所谓「优雅」启停就是在启动退出服务时要满足以下几个条件： 不可以关闭现有连接（进程）新的进程启动并「接管」旧进程连接要随时响应用户请求，不可以出现拒绝请求的情况停止的时候，必须处理完既有连接，并且停止接收新的连接。为此我们必须引用信号来完成这些目的： 启动： 监听SIGHUP（在用户终端连接(正常或非正常)结束时发出）；收到信号后将服务监听的文件描述符传递给新的子进程，此时新老进程同时接收请求；退出： 监听SIGINT和SIGSTP和SIGQUIT等。父进程停止接收新请求，等待旧请求完成（或超时）；父进程退出。实现：go1.8采用Http.Server内置的Shutdown方法支持优雅关机。 然后fvbock&#x2F;endless可以实现优雅重启。 参考资料：gin框架实践连载八 | 如何优雅重启和停止 - 掘金，优雅地关闭或重启 go web 项目 持久化怎么做的？所谓持久化就是将要保存的字符串写到硬盘等设备。 最简单的方式就是采用ioutil的WriteFile()方法将字符串写到磁盘上，这种方法面临格式化方面的问题。更好的做法是将数据按照固定协议进行组织再进行读写，比如JSON，XML，Gob，csv等。如果要考虑高并发和高可用，必须把数据放入到数据库中，比如MySQL，PostgreDB，MongoDB等。参考链接：Golang 持久化 面试题5作者：Dylan2333 链接： 测开转Go开发-面经&amp;总结_笔经面经_牛客网​www.nowcoder.com/discuss/826193?type=post&amp;order=recall&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_post_nctrack&amp;gio_id=9C5DC1FFB3FC3BE29281D7CCFC420365-1645173894793 该试题需要面试者有非常丰富的项目阅历和底层原理经验，熟练使用微服务，etcd，gin，gorm，gRPC等典型框架等模型或框架。 channel 死锁的场景当一个channel中没有数据，而直接读取时，会发生死锁：q :&#x3D; make(chan int,2)&lt;-q解决方案是采用select语句，再default放默认处理方式： q :&#x3D; make(chan int,2)select{ case val:&#x3D;&lt;-q: default: … }当channel数据满了，再尝试写数据会造成死锁：q :&#x3D; make(chan int,2)q&lt;-1q&lt;-2q&lt;-3解决方法，采用select func main() { q :&#x3D; make(chan int, 2) q &lt;- 1 q &lt;- 2 select { case q &lt;- 3: fmt.Println(“ok”) default: fmt.Println(“wrong”) } }向一个关闭的channel写数据。注意：一个已经关闭的channel，只能读数据，不能写数据。 参考资料：Golang关于channel死锁情况的汇总以及解决方案 对已经关闭的chan进行读写会怎么样？读已经关闭的chan能一直读到东西，但是读到的内容根据通道内关闭前是否有元素而不同。如果chan关闭前，buffer内有元素还未读,会正确读到chan内的值，且返回的第二个bool值（是否读成功）为true。如果chan关闭前，buffer内有元素已经被读完，chan内无值，接下来所有接收的值都会非阻塞直接成功，返回 channel 元素的零值，但是第二个bool值一直为false。写已经关闭的chan会panic。 说说 atomic底层怎么实现的.atomic源码位于sync\\atomic。通过阅读源码可知，atomic采用CAS（CompareAndSwap）的方式实现的。所谓CAS就是使用了CPU中的原子性操作。在操作共享变量的时候，CAS不需要对其进行加锁，而是通过类似于乐观锁的方式进行检测，总是假设被操作的值未曾改变（即与旧值相等），并一旦确认这个假设的真实性就立即进行值替换。本质上是不断占用CPU资源来避免加锁的开销。 参考资料：Go语言的原子操作atomic - 编程猎人 channel底层实现？是否线程安全。channel底层实现在src&#x2F;runtime&#x2F;chan.go中 channel内部是一个循环链表。内部包含buf, sendx, recvx, lock ,recvq, sendq几个部分； buf是有缓冲的channel所特有的结构，用来存储缓存数据。是个循环链表； sendx和recvx用于记录buf这个循环链表中的发送或者接收的index；lock是个互斥锁；recvq和sendq分别是接收(&lt;-channel)或者发送(channel &lt;- xxx)的goroutine抽象出来的结构体(sudog)的队列。是个双向链表。channel是线程安全的。 参考资料：Kitou：Golang 深度剖析 – channel的底层实现 map的底层实现。源码位于src\\runtime\\map.go 中。 go的map和C++map不一样，底层实现是哈希表，包括两个部分：hmap和bucket。 里面最重要的是buckets（桶），buckets是一个指针，最终它指向的是一个结构体： &#x2F;&#x2F; A bucket for a Go map.type bmap struct { tophash [bucketCnt]uint8}每个bucket固定包含8个key和value(可以查看源码bucketCnt&#x3D;8).实现上面是一个固定的大小连续内存块，分成四部分：每个条目的状态，8个key值，8个value值，指向下个bucket的指针。 创建哈希表使用的是makemap函数.map 的一个关键点在于，哈希函数的选择。在程序启动时，会检测 cpu 是否支持 aes，如果支持，则使用 aes hash，否则使用 memhash。这是在函数 alginit() 中完成，位于路径：src&#x2F;runtime&#x2F;alg.go 下。 map查找就是将key哈希后得到64位（64位机）用最后B个比特位计算在哪个桶。在 bucket 中，从前往后找到第一个空位。这样，在查找某个 key 时，先找到对应的桶，再去遍历 bucket 中的 key。 关于map的查找和扩容可以参考map的用法到map底层实现分析。 select的实现原理？select源码位于src\\runtime\\select.go，最重要的scase 数据结构为： type scase struct { c *hchan &#x2F;&#x2F; chan elem unsafe.Pointer &#x2F;&#x2F; data element}scase.c为当前case语句所操作的channel指针，这也说明了一个case语句只能操作一个channel。 scase.elem表示缓冲区地址： caseRecv ： scase.elem表示读出channel的数据存放地址；caseSend ： scase.elem表示将要写入channel的数据存放地址；select的主要实现位于：select.go函数：其主要功能如下： 锁定scase语句中所有的channel 按照随机顺序检测scase中的channel是否ready 2.1 如果case可读，则读取channel中数据，解锁所有的channel，然后返回(case index, true) 2.2 如果case可写，则将数据写入channel，解锁所有的channel，然后返回(case index, false) 2.3 所有case都未ready，则解锁所有的channel，然后返回（default index, false） 所有case都未ready，且没有default语句 3.1 将当前协程加入到所有channel的等待队列 3.2 当将协程转入阻塞，等待被唤醒 唤醒后返回channel对应的case index 4.1 如果是读操作，解锁所有的channel，然后返回(case index, true) 4.2 如果是写操作，解锁所有的channel，然后返回(case index, false) 参考资料：Go select的使用和实现原理. go的interface怎么实现的？go interface源码在runtime\\iface.go中。 go的接口由两种类型实现iface和eface。iface是包含方法的接口，而eface不包含方法。 iface对应的数据结构是（位于src\\runtime\\runtime2.go）： type iface struct { tab *itab data unsafe.Pointer}可以简单理解为，tab表示接口的具体结构类型，而data是接口的值。 itab：type itab struct { inter *interfacetype &#x2F;&#x2F;此属性用于定位到具体interface _type *_type &#x2F;&#x2F;此属性用于定位到具体interface hash uint32 &#x2F;&#x2F; copy of _type.hash. Used for type switches. _ [4]byte fun [1]uintptr &#x2F;&#x2F; variable sized. fun[0]&#x3D;&#x3D;0 means _type does not implement inter.}属性interfacetype类似于_type，其作用就是interface的公共描述，类似的还有maptype、arraytype、chantype…其都是各个结构的公共描述，可以理解为一种外在的表现信息。interfaetype和type唯一确定了接口类型，而hash用于查询和类型判断。fun表示方法集。 eface与iface基本一致，但是用_type直接表示类型，这样的话就无法使用方法。 type eface struct { _type *_type data unsafe.Pointer}这里篇幅有限，深入讨论可以看：深入研究 Go interface 底层实现 go的reflect 底层实现go reflect源码位于src\\reflect\\下面，作为一个库独立存在。反射是基于接口实现的。 Go反射有三大法则： 反射从接口映射到反射对象； 法则1反射从反射对象映射到接口值； 法则2只有值可以修改(settable)，才可以修改反射对象。Go反射基于上述三点实现。我们先从最核心的两个源文件入手type.go和value.go. type用于获取当前值的类型。value用于获取当前的值。 参考资料：The Laws of Reflection， 图解go反射实现原理 go GC的原理知道吗？如果需要从源码角度解释GC，推荐阅读（非常详细，图文并茂）： https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/ go里用过哪些设计模式 ?Go设计模式常见面试题【2022版】8 赞同 · 4 评论文章 go的调试&#x2F;分析工具用过哪些。go的自带工具链相当丰富， go cover : 测试代码覆盖率；godoc: 用于生成go文档；pprof：用于性能调优，针对cpu，内存和并发；race：用于竞争检测； 进程被kill，如何保证所有goroutine顺利退出goroutine监听SIGKILL信号，一旦接收到SIGKILL，则立刻退出。可采用select方法。 var wg &#x3D; &amp;sync.WaitGroup{} func main() { wg.Add(1) go func() &#123; c1 := make(chan os.Signal, 1) signal.Notify(c1, syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT) fmt.Printf(&quot;goroutine 1 receive a signal : %v\\n\\n&quot;, &lt;-c1) wg.Done() &#125;() wg.Wait() fmt.Printf(&quot;all groutine done!\\n&quot;) } 说说context包的作用？你用过哪些，原理知道吗？context可以用来在goroutine之间传递上下文信息，相同的context可以传递给运行在不同goroutine中的函数，上下文对于多个goroutine同时使用是安全的，context包定义了上下文类型，可以使用background、TODO创建一个上下文，在函数调用链之间传播context，也可以使用WithDeadline、WithTimeout、WithCancel 或 WithValue 创建的修改副本替换它，听起来有点绕，其实总结起就是一句话：context的作用就是在不同的goroutine之间同步请求特定的数据、取消信号以及处理请求的截止日期。 关于context原理，可以参看：小白也能看懂的context包详解：从入门到精通 grpc为啥好，基本原理是什么，和http比呢官方介绍：gRPC 是一个现代开源的高性能远程过程调用 (RPC) 框架，可以在任何环境中运行。它可以通过对负载平衡、跟踪、健康检查和身份验证的可插拔支持有效地连接数据中心内和跨数据中心的服务。它也适用于分布式计算的最后一英里，将设备、移动应用程序和浏览器连接到后端服务。 区别： rpc是远程过程调用，就是本地去调用一个远程的函数，而http是通过 url和符合restful风格的数据包去发送和获取数据； rpc的一般使用的编解码协议更加高效，比如grpc使用protobuf编解码。而http的一般使用json进行编解码，数据相比rpc更加直观，但是数据包也更大，效率低下； rpc一般用在服务内部的相互调用，而http则用于和用户交互；相似点：都有类似的机制，例如grpc的metadata机制和http的头机制作用相似，而且web框架，和rpc框架中都有拦截器的概念。grpc使用的是http2.0协议。官网：gRPC etcd怎么搭建的，具体怎么用的熔断怎么做的服务降级怎么搞1亿条数据动态增长，取top10，怎么实现进程挂了怎么办nginx配置过吗，有哪些注意的点设计一个阻塞队列mq消费阻塞怎么办性能没达到预期，有什么解决方案 编程系列实现使用字符串函数名，调用函数。思路：采用反射的Call方法实现。 package mainimport ( “fmt” “reflect”) type Animal struct{ } func (a *Animal) Eat(){ fmt.Println(“Eat”)} func main(){ a :&#x3D; Animal{} reflect.ValueOf(&amp;a).MethodByName(“Eat”).Call([]reflect.Value{}) } （Goroutine）有三个函数，分别打印”cat”, “fish”,”dog”要求每一个函数都用一个goroutine，按照顺序打印100次。此题目考察channel，用三个无缓冲channel，如果一个channel收到信号则通知下一个。 package main import ( “fmt” “time”) var dog &#x3D; make(chan struct{})var cat &#x3D; make(chan struct{})var fish &#x3D; make(chan struct{}) func Dog() { &lt;-fish fmt.Println(“dog”) dog &lt;- struct{}{}} func Cat() { &lt;-dog fmt.Println(“cat”) cat &lt;- struct{}{}} func Fish() { &lt;-cat fmt.Println(“fish”) fish &lt;- struct{}{}} func main() { for i :&#x3D; 0; i &lt; 100; i++ { go Dog() go Cat() go Fish() } fish &lt;- struct{}{} time.Sleep(10 * time.Second) } 两个协程交替打印10个字母和数字思路：采用channel来协调goroutine之间顺序。 主线程一般要waitGroup等待协程退出，这里简化了一下直接sleep。 package main import ( “fmt” “time”) var word &#x3D; make(chan struct{}, 1)var num &#x3D; make(chan struct{}, 1) func printNums() { for i :&#x3D; 0; i &lt; 10; i++ { &lt;-word fmt.Println(1) num &lt;- struct{}{} }}func printWords() { for i :&#x3D; 0; i &lt; 10; i++ { &lt;-num fmt.Println(“a”) word &lt;- struct{}{} }} func main() { num &lt;- struct{}{} go printNums() go printWords() time.Sleep(time.Second * 1)}代码： @中二的灰太狼 启动 2个groutine 2秒后取消， 第一个协程1秒执行完，第二个协程3秒执行完。思路：采用ctx, _ :&#x3D; context.WithTimeout(context.Background(), time.Second*2)实现2s取消。协程执行完后通过channel通知，是否超时。 package main import ( “context” “fmt” “time”) func f1(in chan struct{}) { time.Sleep(1 * time.Second) in &lt;- struct&#123;&#125;&#123;&#125; } func f2(in chan struct{}) { time.Sleep(3 * time.Second) in &lt;- struct{}{}} func main() { ch1 :&#x3D; make(chan struct{}) ch2 :&#x3D; make(chan struct{}) ctx, _ :&#x3D; context.WithTimeout(context.Background(), 2*time.Second) go func() &#123; go f1(ch1) select &#123; case &lt;-ctx.Done(): fmt.Println(&quot;f1 timeout&quot;) break case &lt;-ch1: fmt.Println(&quot;f1 done&quot;) &#125; &#125;() go func() &#123; go f2(ch2) select &#123; case &lt;-ctx.Done(): fmt.Println(&quot;f2 timeout&quot;) break case &lt;-ch2: fmt.Println(&quot;f2 done&quot;) &#125; &#125;() time.Sleep(time.Second * 5) }代码： @中二的灰太狼 当select监控多个chan同时到达就绪态时，如何先执行某个任务？可以在子case再加一个for select语句。 func priority_select(ch1, ch2 &lt;-chan string) { for { select { case val :&#x3D; &lt;-ch1: fmt.Println(val) case val2 :&#x3D; &lt;-ch2: priority: for { select { case val1 :&#x3D; &lt;-ch1: fmt.Println(val1) default: break priority &#125; &#125; fmt.Println(val2) &#125; &#125; } 总结Go面试复习应该有所侧重，关注切片，通道，异常处理，Goroutine，GMP模型，字符串高效拼接，指针，反射，接口，sync。对于比较难懂的部分，GMP模型和GC和内存管理，应该主动去看源码，然后慢慢理解。业务代码写多了，自然就有理解了。 https://zhuanlan.zhihu.com/p/471490292","categories":[],"tags":[]},{"title":"go常用设计模式","slug":"go常用设计模式","date":"2023-02-10T17:51:34.000Z","updated":"2023-02-10T18:04:01.363Z","comments":true,"path":"/2023/02/11/go常用设计模式/","link":"","permalink":"https://hiro-lin.github.io/2023/02/11/go%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1 创建型模式1.1 工厂方法模式❓问题描述：假设你正在开发一款物流管理应用。 最初版本只能处理卡车运输， 因此大部分代码都在位于名为 卡车的类中。 一段时间后， 这款应用变得极受欢迎。 你每天都能收到十几次来自海运公司的请求， 希望应用能够支持海上物流功能。 解决方案：我们抽象出一个物流工厂，然后分别实例化陆上，海上物流等工厂类，再生产对应产品。 首先写一个表示通用物流的接口： 1234type iLogistics interface &#123; setName(string) getName() string&#125; 之后就是陆上物流的工厂类： 12345678910111213type RoadLogistics struct &#123; name string&#125;func (r *RoadLogistics) setName(name string) &#123; r.name = name&#125;func (r *RoadLogistics) getName() string &#123; return r.name&#125;var roadInstance iLogistics = (*RoadLogistics)(nil) // 验证RoadLogistics是否实习了接口iLogistics 以及海上物流的工厂类，因为类似这里就省略了。 之后就是具体产品了，比如陆上的有汽车，火车和高铁。 1234567891011type Vehicle struct &#123; RoadLogistics&#125;func NewVehicle() (v *Vehicle) &#123; v = new(Vehicle) v.RoadLogistics = RoadLogistics&#123; Name: &quot;vehicle&quot;, &#125; return v&#125; 上面是汽车的例子，我们再写一个火车的例子： 1234567891011type Train struct &#123; RoadLogistics&#125;func NewTrain() (t *Train) &#123; t = new(Train) t.RoadLogistics = RoadLogistics&#123; Name: &quot;train&quot;, &#125; return t&#125; 然后我们可以根据类别，直接初始化对应的类： 12345678func getLogistics(means string) (i iLogistics, err error)&#123; if means == &quot;vehicle&quot; &#123; return NewVehicle(), nil &#125;else if means == &quot;train&quot;&#123; return NewTrain(), nil &#125; return nil, errors.New(&quot;unknown means of transportation&quot;)&#125; 客户端使用，直接调用getLogistics就好。 1.2 抽象工厂模式抽象工厂模式是一种创建型设计模式，它能创建一系列相关的对象，而无需指定其具体类。 ❓问题描述：假设一下，如果你想要购买一组运动装备，比如一双鞋与一件衬衫这样由两种不同产品组合而成的套装。相信你会想去购买同一品牌的商品，这样商品之间能够互相搭配起来。 解决方案：首先，抽象工厂模式为系列中的每件产品明确声明接口（例如T恤或者鞋子）。然后，确保所有产品变体都继承这些接口。 下面是一个抽象工厂接口，它能产生工厂类 12345678910111213141516type iSportsFactory interface &#123; makeShoe() iShoe makeShirt() iShirt&#125;func getSportsFactory(brand string) (iSportsFactory, error) &#123; if brand == &quot;adidas&quot; &#123; return &amp;adidas&#123;&#125;, nil &#125; if brand == &quot;nike&quot; &#123; return &amp;nike&#123;&#125;, nil &#125; return nil, fmt.Errorf(&quot;Wrong brand type passed&quot;)&#125; 现在有一个adidas的工厂： 1234567891011121314151617181920type adidas struct &#123;&#125;func (a *adidas) makeShoe() iShoe &#123; return &amp;adidasShoe&#123; shoe: shoe&#123; logo: &quot;adidas&quot;, size: 14, &#125;, &#125;&#125;func (a *adidas) makeShirt() iShirt &#123; return &amp;adidasShirt&#123; shirt: shirt&#123; logo: &quot;adidas&quot;, size: 14, &#125;, &#125;&#125; 和nike的工厂（略）。 然后是抽象的产品，它有尺寸和logo两个属性： 123456789101112131415161718192021222324252627type iShoe interface &#123; setLogo(logo string) setSize(size int) getLogo() string getSize() int&#125;type shoe struct &#123; logo string size int&#125;func (s *shoe) setLogo(logo string) &#123; s.logo = logo&#125;func (s *shoe) getLogo() string &#123; return s.logo&#125;func (s *shoe) setSize(size int) &#123; s.size = size&#125;func (s *shoe) getSize() int &#123; return s.size&#125; adidas工厂必须能生产鞋子： 123type adidasShoe struct &#123; shoe&#125; 客户端代码： 12345678910func main() &#123; adidasFactory, _ := getSportsFactory(&quot;adidas&quot;) nikeFactory, _ := getSportsFactory(&quot;nike&quot;) nikeShoe := nikeFactory.makeShoe() nikeShirt := nikeFactory.makeShirt() adidasShoe := adidasFactory.makeShoe() adidasShirt := adidasFactory.makeShirt()&#125; 工厂方法模式和抽象工厂模式的区别在于：前者实例化具体的产品，后者实例化具体的工厂，每个工厂再实例化同样的产品系列。 1.3 单例模式单例模式是一种创建型设计模式，一个类仅有一个实例，并提供访问该实例的全局节点。 ❓问题描述：假设一下，如果你想要为你的工程建立一个日志Logger模块，但你只需要全局唯一的日志系统，不希望日志被记录到乱七八糟的位置。 解决方案：我们需要考虑两个问题：1.如何确保全局唯一，2.如何保证并发控制。 go里面有sync.Once 方法，能非常优雅的解决这些问题。 12345678910111213141516type Logger struct &#123;&#125;var logger *Loggervar once sync.Oncefunc getLoggerInstance() *Logger &#123; if logger == nil &#123; once.Do( func() &#123; logger = &amp;Logger&#123;&#125; &#125;) &#125; return logger&#125; sync.Once内部原理是使用了一个互斥锁，每次检查该变量有无被分配（是否为nil），只有为nil才初始化实例。 1.4 生成器模式生成器模式允许你分步创建复杂的对象。 假设你的构造函数有很多参数，那么调用该函数将非常不方便。在C#和python这样支持重载的语言还好，对于go来说就是灾难。 ❓问题描述：假设一下，我们需要在游戏里设计不同的虚拟房屋，每个房子有不同的门和窗户等属性。现在有两种类型的房屋normal和igloo（木制）。 解决方案：我们需要考虑两个问题：1.如何确保全局唯一，2.如何保证并发控制。 定义生成器接口： 1234567891011121314151617type iBuilder interface &#123; setWindowType() setDoorType() setNumFloor() getHouse() house&#125;func getBuilder(builderType string) iBuilder &#123; if builderType == &quot;normal&quot; &#123; return &amp;normalBuilder&#123;&#125; &#125; if builderType == &quot;igloo&quot; &#123; return &amp;iglooBuilder&#123;&#125; &#125; return nil&#125; 具体的房屋生成器（以normal为例子）： 1234567891011121314151617181920212223242526272829type normalBuilder struct &#123; windowType string doorType string floor int&#125;func newNormalBuilder() *normalBuilder &#123; return &amp;normalBuilder&#123;&#125;&#125;func (b *normalBuilder) setWindowType() &#123; b.windowType = &quot;Wooden Window&quot;&#125;func (b *normalBuilder) setDoorType() &#123; b.doorType = &quot;Wooden Door&quot;&#125;func (b *normalBuilder) setNumFloor() &#123; b.floor = 2&#125;func (b *normalBuilder) getHouse() house &#123; return house&#123; doorType: b.doorType, windowType: b.windowType, floor: b.floor, &#125;&#125; 房屋（产品）： 12345type house struct &#123; windowType string doorType string floor int&#125; 定义一个主管，他手下有可以修建所有类型房屋的工人。 1234567891011121314151617181920type director struct &#123; builder iBuilder&#125;func newDirector(b iBuilder) *director &#123; return &amp;director&#123; builder: b, &#125;&#125;func (d *director) setBuilder(b iBuilder) &#123; d.builder = b&#125;func (d *director) buildHouse() house &#123; d.builder.setDoorType() d.builder.setWindowType() d.builder.setNumFloor() return d.builder.getHouse()&#125; 客户端代码： 123456789101112131415161718func main() &#123; normalBuilder := getBuilder(&quot;normal&quot;) iglooBuilder := getBuilder(&quot;igloo&quot;) director := newDirector(normalBuilder) normalHouse := director.buildHouse() fmt.Printf(&quot;Normal House Door Type: %s\\n&quot;, normalHouse.doorType) fmt.Printf(&quot;Normal House Window Type: %s\\n&quot;, normalHouse.windowType) fmt.Printf(&quot;Normal House Num Floor: %d\\n&quot;, normalHouse.floor) director.setBuilder(iglooBuilder) iglooHouse := director.buildHouse() fmt.Printf(&quot;\\nIgloo House Door Type: %s\\n&quot;, iglooHouse.doorType) fmt.Printf(&quot;Igloo House Window Type: %s\\n&quot;, iglooHouse.windowType) fmt.Printf(&quot;Igloo House Num Floor: %d\\n&quot;, iglooHouse.floor)&#125; 1.5 原型模式原型模式使你能够复制已有对象，无需使代码依赖它们所属的类。 ❓问题描述：假设一下，你有一个原型，你想复制出一个一模一样的复制品，但不巧的是，类的某些成员（比如登录模块）是私有的。 解决方案：在原型类实现公共方法clone()能够返回对象的复制。 让我们尝试通过基于操作系统文件系统的示例来理解原型模式。 操作系统的文件系统是递归的： 文件夹中包含文件和文件夹， 其中又包含文件和文件夹， 以此类推。 每个文件和文件夹都可用一个 inode接口来表示。 ​ inode接口中同样也有 clone克隆功能。 file文件和 fold­er文件夹结构体都实现了 print打印和 clone方法， 因为它们都是 inode类型。 同时， 注意 file和 fold­er中的 clone方法。 这两者的 clone方法都会返回相应文件或文件夹的副本。 同时在克隆过程中， 我们会在其名称后面添加 “_clone” 字样。 原型接口： 1234type inode interface &#123; print(string) clone() inode&#125; 文件原型： 1234567891011type file struct &#123; name string&#125;func (f *file) print(indentation string) &#123; fmt.Println(indentation + f.name)&#125;func (f *file) clone() inode &#123; return &amp;file&#123;name: f.name + &quot;_clone&quot;&#125;&#125; 文件夹原型： 12345678910111213141516171819202122type folder struct &#123; children []inode name string&#125;func (f *folder) print(indentation string) &#123; fmt.Println(indentation + f.name) for _, i := range f.children &#123; i.print(indentation + indentation) &#125;&#125;func (f *folder) clone() inode &#123; cloneFolder := &amp;folder&#123;name: f.name + &quot;_clone&quot;&#125; var tempChildren []inode for _, i := range f.children &#123; copy := i.clone() tempChildren = append(tempChildren, copy) &#125; cloneFolder.children = tempChildren return cloneFolder&#125; 客户端代码： 123456789101112131415161718192021func main() &#123; file1 := &amp;file&#123;name: &quot;File1&quot;&#125; file2 := &amp;file&#123;name: &quot;File2&quot;&#125; file3 := &amp;file&#123;name: &quot;File3&quot;&#125; folder1 := &amp;folder&#123; children: []inode&#123;file1&#125;, name: &quot;Folder1&quot;, &#125; folder2 := &amp;folder&#123; children: []inode&#123;folder1, file2, file3&#125;, name: &quot;Folder2&quot;, &#125; fmt.Println(&quot;\\nPrinting hierarchy for Folder2&quot;) folder2.print(&quot; &quot;) cloneFolder := folder2.clone() fmt.Println(&quot;\\nPrinting hierarchy for clone Folder&quot;) cloneFolder.print(&quot; &quot;)&#125; 1.6 创建型小结 在许多设计工作的初期都会使用工厂方法模式 （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用抽象工厂模式、 原型模式或生成器模式 （更灵活但更加复杂）。 生成器重点关注如何分步生成复杂对象。 抽象工厂专门用于生产一系列相关对象。 抽象工厂会马上返回产品， 生成器则允许你在获取产品前执行一些额外构造步骤。 你可以在创建复杂组合模式树时使用生成器， 因为这可使其构造步骤以递归的方式运行。 你可以结合使用生成器和桥接模式： 主管类负责抽象工作， 各种不同的生成器负责实现工作。 抽象工厂、 生成器和原型都可以用单例模式来实现。","categories":[],"tags":[]},{"title":"MongoDB面试题","slug":"MongoDB面试题","date":"2023-02-10T17:27:17.000Z","updated":"2023-02-10T17:38:41.602Z","comments":true,"path":"/2023/02/11/MongoDB面试题/","link":"","permalink":"https://hiro-lin.github.io/2023/02/11/MongoDB%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"1.什么是MongoDB MongoDB是一个文档数据库，提供好的性能，领先的非关系型数据库。采用BSON存储文档数据。BSON（）是一种类json的一种二进制形式的存储格式，简称Binary JSON.相对于json多了date类型和二进制数组。 2.MongoDB的优势有哪些 面向文档的存储：以 JSON 格式的文档保存数据。任何属性都可以建立索引。复制以及高可扩展性。自动分片。丰富的查询功能。快速的即时更新。 3.什么是数据库 数据库可以看成是一个电子化的文件柜,用户可以对文件中的数据运行新增、检索、更新、删除等操作。数据库是一个所有集合的容器，在文件系统中每一个数据库都有一个相关的物理文件。 4.什么是集合(表) 集合就是一组 MongoDB 文档。它相当于关系型数据库（RDBMS）中的表这种概念。集合位于单独的一个数据库中。一个集合内的多个文档可以有多个不同的字段。一般来说，集合中的文档都有着相同或相关的目的。 5.什么是文档(记录) 文档由一组key value组成。文档是动态模式,这意味着同一集合里的文档不需要有相同的字段和结构。在关系型数据库中table中的每一条记录相当于MongoDB中的一个文 6.MongoDB和关系型数据库术语对比图 7.什么是非关系型数据库 非关系型数据库的显著特点是不使用SQL作为查询语言，数据存储不需要特定的表格模式。 8 为什么用MOngoDB？ 架构简单没有复杂的连接深度查询能力,MongoDB支持动态查询。容易调试容易扩展不需要转化&#x2F;映射应用对象到数据库对象使用内部内存作为存储工作区,以便更快的存取数据。 9 在哪些场景使用MongoDB 大数据内容管理系统移动端Apps数据管理 10 MongoDB中的命名空间是什么意思? mongodb存储bson对象在丛集(collection)中.数据库名字和丛集名字以句点连结起来叫做名字空间(namespace). 一个集合命名空间又有多个数据域(extent)，集合命名空间里存储着集合的元数据，比如集合名称，集合的第一个数据域和最后一个数据域的位置等等。而一个数据域由若干条文档(document)组成，每个数据域都有一个头部，记录着第一条文档和最后一条文档的为知，以及该数据域的一些元数据。extent之间，document之间通过双向链表连接。 索引的存储数据结构是B树，索引命名空间存储着对B树的根节点的指针。 11 monogodb 中的分片什么意思 分片是将数据水平切分到不同的物理节点。当应用数据越来越大的时候，数据量也会越来越大。当数据量增长时，单台机器有可能无法存储数据或可接受的读取写入吞吐量。利用分片技术可以添加更多的机器来应对数据量增加以及读写操作的要求。 12 为什么要在MongoDB中使用分析器 mongodb中包括了一个可以显示数据库中每个操作性能特点的数据库分析器.通过这个分析器你可以找到比预期慢的查询(或写操作);利用这一信息,比如,可以确定是否需要添加索引. 13 .MongoDB支持主键外键关系吗 默认MongoDB不支持主键和外键关系。 用Mongodb本身的API需要硬编码才能实现外键关联，不够直观且难度较大 14 MongoDB支持哪些数据类型 StringIntegerDoubleBooleanObjectObject IDArraysMin&#x2F;Max KeysDatetimeCodeRegular Expression等 15 为什么要在MongoDB中用”Code”数据类型 “Code”类型用于在文档中存储 JavaScript 代码。 16 为什么要在MongoDB中用”Regular Expression”数据类型 “Regular Expression”类型用于在文档中存储正则表达式 17 为什么在MongoDB中使用”Object ID”数据类型 “ObjectID”数据类型用于存储文档id 18”ObjectID”有哪些部分组成 一共有四部分组成:时间戳、客户端ID、客户进程ID、三个字节的增量计数器 19 在MongoDb中什么是索引 索引用于高效的执行查询,没有索引的MongoDB将扫描整个集合中的所有文档,这种扫描效率很低,需要处理大量的数据. 索引是一种特殊的数据结构,将一小块数据集合保存为容易遍历的形式.索引能够存储某种特殊字段或字段集的值,并按照索引指定的方式将字段值进行排序. 20 如何添加索引 使用db.collection.createIndex()在集合中创建一个索引 21.如何查询集合中的文档 db.collectionName.find({key:value}) 22用什么方法可以格式化输出结果 db.collectionName.find().pretty() 23 如何使用”AND”或”OR”条件循环查询集合中的文档 db.mycol.find( { $or: [ {key1: value1}, {key2:value2} ] } ).pretty() 24 更新数据 db.collectionName.update({key:value},{$set:{newkey:newValue}}) 25 如何删除文档 db.collectionName.remove({key:value}) 26 在MongoDB中如何排序 并使用 1 和 -1 来指定排序方式，其中 1 表示升序，而 -1 表示降序。 db.connectionName.find({key:value}).sort({columnName:1}) 27 什么是聚合 聚合操作能够处理数据记录并返回计算结果。聚合操作能将多个文档中的值组合起来，对成组数据执行各种操作，返回单一的结果。它相当于 SQL 中的 count(*) 组合 group by。对于 MongoDB 中的聚合操作，应该使用aggregate()方法。 db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION) 28 在MongoDB中什么是副本集（避免单点故障） 在MongoDB中副本集由一组MongoDB实例组成，包括一个主节点多个次节点，MongoDB客户端的所有数据都写入主节点(Primary),副节点从主节点同步写入数据，以保持所有复制集内存储相同的数据，提高数据可用性。 29 什么是NoSQL数据库？NoSQL和RDBMS有什么区别？在哪些情况下使用和不使用NoSQL数据库？ NoSQL是非关系型数据库，NoSQL &#x3D; Not Only SQL。关系型数据库采用的结构化的数据，NoSQL采用的是键值对的方式存储数据。 在处理非结构化&#x2F;半结构化的大数据时；在水平方向上进行扩展时；随时应对动态增加的数据项时可以优先考虑使用NoSQL数据库。 在考虑数据库的成熟度；支持；分析和商业智能；管理及专业性等问题时，应优先考虑关系型数据库。 30 MongoDB支持存储过程吗？如果支持的话，怎么用？ MongoDB支持存储过程，它是javascript写的，保存在db.system.js表中。 31如何理解MongoDB中的GridFS机制，MongoDB为何使用GridFS来存储文件？ GridFS是一种将大型文件存储在MongoDB中的文件规范。使用GridFS可以将大文件分隔成多个小文档存放，这样我们能够有效的保存大文档，而且解决了BSON对象有限制的问题。 32 为什么MongoDB的数据文件很大？ MongoDB采用的预分配空间的方式来防止文件碎片。 33 当更新一个正在被迁移的块（Chunk）上的文档时会发生什么？ 更新操作会立即发生在旧的块（Chunk）上，然后更改才会在所有权转移前复制到新的分片上。 34 MongoDB在A:{B,C}上建立索引，查询A:{B,C}和A:{C,B}都会使用索引吗？ 不会，只会在A:{B,C}上使用索引。 35 mongodb成为最好nosql数据库的原因是什么? 面向文件的 高性能 高可用性 易扩展性 丰富的查询语言 36 如果用户移除对象的属性,该属性是否从存储层中删除? 是的,用户移除属性然后对象会重新保存(re-save()). 37 允许空值null吗? 对于对象成员而言,是的.然而用户不能够添加空值(null)到数据库丛集(collection)因为空值不是对象.然而用户能够添加空对象{}. 38 更新操作立刻fsync到磁盘? 不会,磁盘写操作默认是延迟执行的.写操作可能在两三秒(默认在60秒内)后到达磁盘.例如,如果一秒内数据库收到一千个对一个对象递增的操作,仅刷新磁盘一次. 39 如何执行事务&#x2F;加锁? mongodb没有使用传统的锁或者复杂的带回滚的事务,因为它设计的宗旨是轻量,快速以及可预计的高性能.可以把它类比成mysql mylsam的自动提交模式.通过精简对事务的支持,性能得到了提升,特别是在一个可能会穿过多个服务器的系统里. 40 启用备份故障恢复需要多久? 从备份数据库声明主数据库宕机到选出一个备份数据库作为新的主数据库将花费10到30秒时间.这期间在主数据库上的操作将会失败–包括写入和强一致性读取(strong consistent read)操作.然而,你还能在第二数据库上执行最终一致性查询(eventually consistent query)(在slaveok模式下),即使在这段时间里. 41 什么是master或primary? 它是当前备份集群(replica set)中负责处理所有写入操作的主要节点&#x2F;成员.在一个备份集群中,当失效备援(failover)事件发生时,一个另外的成员会变成primary. 42 我应该启动一个集群分片(sharded)还是一个非集群分片的 mongodb 环境? (数据量大用集群分片,数据量小用非集群) 为开发便捷起见,我们建议以非集群分片(unsharded)方式开始一个 mongodb 环境,除非一台服务器不足以存放你的初始数据集.从非集群分片升级到集群分片(sharding)是无缝的,所以在你的数据集还不是很大的时候没必要考虑集群分片(sharding). 43 分片(sharding)和复制(replication)是怎样工作的? 每一个分片(shard)是一个分区数据的逻辑集合.分片可能由单一服务器或者集群组成,我们推荐为每一个分片(shard)使用集群. 44数据在什么时候才会扩展到多个分片(shard)里? mongodb 分片是基于区域(range)的.所以一个集合(collection)中的所有的对象都被存放到一个块(chunk)中.只有当存在多余一个块的时候,才会有多个分片获取数据的选项.现在,每个默认块的大小是 64mb,所以你需要至少 64 mb 空间才可以实施一个迁移. 45 当我试图更新一个正在被迁移的块(chunk)上的文档时会发生什么? 更新操作会立即发生在旧的分片(shard)上,然后更改才会在所有权转移(ownership transfers)前复制到新的分片上. 46 如果在一个分片(shard)停止或者很慢的时候,我发起一个查询会怎样? 如果一个分片(shard)停止了,除非查询设置了“partial”选项,否则查询会返回一个错误.如果一个分片(shard)响应很慢,mongodb则会等待它的响应. 47 可以把movechunk目录里的旧文件删除吗? 没问题,这些文件是在分片(shard)进行均衡操作(balancing)的时候产生的临时文件.一旦这些操作已经完成,相关的临时文件也应该被删除掉.但目前清理工作是需要手动的,所以请小心地考虑再释放这些文件的空间. 48 如果块移动操作(movechunk)失败了,我需要手动清除部分转移的文档吗? 不需要,移动操作是一致(consistent)并且是确定性的(deterministic);一次失败后,移动操作会不断重试;当完成后,数据只会出现在新的分片里(shard). 49 mongodb是否支持事务 MongoDB 4.0的新特性——事务（Transactions）：MongoDB 是不支持事务的，因此开发者在需要用到事务的时候，不得不借用其他工具，在业务代码层面去弥补数据库的不足。 事务和会话(Sessions)关联，一个会话同一时刻只能开启一个事务操作，当一个会话断开，这个会话中的事务也会结束。 ————————————————版权声明：本文为CSDN博主「KangJinXuan」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/KangJinXuan/article/details/126936926","categories":[],"tags":[]},{"title":"TCP/IP协议常见面试题","slug":"TCP-IP协议常见面试题","date":"2023-02-10T13:00:31.000Z","updated":"2023-02-10T13:07:12.194Z","comments":true,"path":"/2023/02/10/TCP-IP协议常见面试题/","link":"","permalink":"https://hiro-lin.github.io/2023/02/10/TCP-IP%E5%8D%8F%E8%AE%AE%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"1、简述TCP的三次握手和四次挥手SYN:请求建立连接，FIN：请求断开连接，ACK:确认是否有效， seq:序列号， ack:确认号 1）三次握手 1.客户端向服务端发送⼀个SYN&#x3D;1（请求建立连接），并生成一个序列号seq&#x3D;j。 2.服务端接收到SYN&#x3D;1后，给客户端发送⼀个SYN&#x3D;1与ACK&#x3D;1；并将ack置为j+1;同时生成一个序列号seq&#x3D;k。 3.客户端接收到会检查ack是否为j+1与ACK是否为1，如果是，则会给服务端发送一个ACK&#x3D;1与ack&#x3D;k+1，以及自己的序列号seq&#x3D;j&#x3D;1; 服务端接收到会检查ACK是否为1与ack是否为k+1,如果是则代表连接建立成功，两者间可以传递数据。 2）四次挥手 1.客户端向服务端发送FIN&#x3D;1（请求关闭连接），并生成一个序列号seq&#x3D;x。 2.服务端接收FIN后，向客户端发送ACK&#x3D;1，ack&#x3D;x+1，并生成序列号seq&#x3D;y（客户端无数据发送，但服务器端需发送完最后的数据）。 3.服务端处理完所有数据后，向客户端发送FIN&#x3D;1与ACK&#x3D;1，ack&#x3D;x+1，并生成序列号z，表示服务端现在可以断开连接。 4.客户端收到服务端的数据包后，会向服务端发送ACK&#x3D;1,seq&#x3D;x&#x3D;1，ack&#x3D;z+1（需要等待2MSL后才可断开连接）。 2、为什么是三次握手而不是两次握手？ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;因为如果客户端第一次发送的SYN报文因为网络问题而迟迟没有到达服务端，此时客户端会因为超时而重新发送一个新的SYN报文，此时上一个SYN报文在客户端就会失效，如果这里只采用两次握手，会因为客户端第二次发送SYN后，第一次发送的SYN又成功到达服务端，这时就会建立两个连接，产生问题。 3、为什么连接的时候是三次握手，关闭的时候却是四次握手？ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。 4、为什么需要经过2MSL(报文段在网络中最大生存时间)才能返回到CLOSE状态？ &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;是为了给最后一次发送的ACK报文成功到达服务端预留时间，因为如果因为网络阻塞最后一次ACK未能及时到达服务端，服务端会以为客户端为收到上一次发送的FIN报文，则服务端会重新发送FIN报文，而这是客户端已经断开连接了，这时就是产生错乱的问题。 5、TCP与UDP的区别 UDP适合广播发送，效率高但是不可靠。 TCP适合两个对象间传递数据，可靠性高但是效率低。————————————————版权声明：本文为CSDN博主「思泽Elly」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_41696018/article/details/124249818","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://hiro-lin.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"TCP","slug":"TCP","permalink":"https://hiro-lin.github.io/tags/TCP/"},{"name":"IP","slug":"IP","permalink":"https://hiro-lin.github.io/tags/IP/"},{"name":"UDP","slug":"UDP","permalink":"https://hiro-lin.github.io/tags/UDP/"}]},{"title":"http与https的区别","slug":"http与https的区别","date":"2023-02-10T11:43:20.000Z","updated":"2023-02-10T13:07:03.954Z","comments":true,"path":"/2023/02/10/http与https的区别/","link":"","permalink":"https://hiro-lin.github.io/2023/02/10/http%E4%B8%8Ehttps%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"一、HTTP 与 HTTPS 的基本概念HTTP： 超文本传输协议（HTTP，HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。它可以使浏览器更加高效。HTTP 协议是以明文方式发送信息的，如果黑客截取了 Web 浏览器和服务器之间的传输报文，就可以直接获得其中的信息。 HTTP 原理: 客户端的浏览器首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的，一般 TCP 连接的端口号是80。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URI）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和许可内容。 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。 HTTPS:是以安全为目标的 HTTP 通道，是 HTTP 的安全版。HTTPS 的安全基础是 SSL。SSL 协议位于 TCP&#x2F;IP 协议与各种应用层协议之间，为数据通讯提供安全支持。SSL 协议可分为两层：SSL 记录协议（SSL Record Protocol），它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。SSL 握手协议（SSL Handshake Protocol），它建立在 SSL 记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。 HTTPS 设计目标： (1) 数据保密性：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么 。 (2) 数据完整性：及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收 。 (3) 身份校验安全性：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方 。 二、HTTP 与 HTTPS 的区别1、HTTPS 协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书较少，因而需要一定费用。(以前的网易官网是http，而网易邮箱是 https 。) 2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议。 3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。) 三、HTTPS 相对于 HTTP 的改进双向的身份认证 客户端和服务端在传输数据之前，会通过基于X.509证书对双方进行身份认证 。具体过程如下： 客户端发起 SSL 握手消息给服务端要求连接。 服务端将证书发送给客户端。 客户端检查服务端证书，确认是否由自己信任的证书签发机构签发(客户端内置了所有受信任 CA 的证书)。 如果不是，将是否继续通讯的决定权交给用户选择 ( 注意，这里将是一个安全缺陷 )。如果检查无误或者用户选择继续，则客户端认可服务端的身份。 服务端要求客户端发送证书，并检查是否通过验证。失败则关闭连接，认证成功则从客户端证书中获得客户端的公钥，一般为 1024 位或者 2048 位。到此，服务器客户端双方的身份认证结束，双方确保身份都是真实可靠的。 注意： (1) 采用 HTTPS 协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问。这套证书其实就是一对公钥和私钥。 (2) 互联网有太多的服务需要使用证书来验证身份，以至于客户端（操作系统或浏览器等）无法内置所有证书，需要通过服务端将证书发送给客户端。 (3) 客户端内置的是 CA 的根证书(Root Certificate)，HTTPS 协议中服务器会发送证书链（Certificate Chain）给客户端。 数据传输的机密性 客户端和服务端在开始传输数据之前，会协商传输过程需要使用的加密算法。 客户端发送协商请求给服务端, 其中包含自己支持的非对成加密的密钥交换算法 ( 一般是RSA)，数据签名摘要算法 ( 一般是SHA或者MD5) ，加密传输数据的对称加密算法 ( 一般是DES)，以及加密密钥的长度。 服务端接收到消息之后，选中安全性最高的算法，并将选中的算法发送给客户端，完成协商。客户端生成随机的字符串，通过协商好的非对称加密算法，使用服务端的公钥对该字符串进行加密，发送给服务端。 服务端接收到之后，使用自己的私钥解密得到该字符串。在随后的数据传输当中，使用这个字符串作为密钥进行对称加密。 防止重放攻击 SSL 使用序列号来保护通讯方免受报文重放攻击。这个序列号被加密后作为数据包的负载。在整个 SSL 握手中，都有一个唯一的随机数来标记 SSL 握手。 这样防止了攻击者嗅探整个登录过程，获取到加密的登录数据之后，不对数据进行解密，而直接重传登录数据包的攻击手法。 可以看到，鉴于电子商务等安全上的需求，HTTPS 对比 HTTP 协议，在安全方面已经取得了极大的增强。总结来说，HTTPS 的改进点在于创造性的使用了非对称加密算法，在不安全的网路上，安全的传输了用来进行非对称加密的密钥，综合利用了非对称加密的安全性和对称加密的快速性。 四、HTTPS 的优点1、使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。 2、HTTPS 协议是由SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、修改，确保数据的完整性。 3、HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。 五、HTTPS 的缺点（对比优点）1、HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近。 2、HTTPS 连接缓存不如 HTTP 高效，会增加数据开销，甚至已有的安全措施也会因此而受到影响。 3、HTTPS 协议的安全是有范围的，在黑客攻击、拒绝服务攻击和服务器劫持等方面几乎起不到什么作用。 4、SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗。 5、成本增加。部署 HTTPS 后，因为 HTTPS 协议的工作要增加额外的计算资源消耗，例如 SSL 协议加密算法和 SSL 交互次数将占用一定的计算资源和服务器成本。 6、HTTPS 协议的加密范围也比较有限。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。 六、HTTPS 的连接过程 图片中的过程是按 8 个步骤分的，但是网上有更详细的步骤，所以我把详细的过程和这个图片配在一起。 ① 客户端的浏览器向服务器发送请求，并传送客户端 SSL 协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。 ② 服务器向客户端传送 SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。 ③ 客户端利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的 CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的 “发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四步。 ④ 用户端随机产生一个用于通讯的 “对称密码”，然后用服务器的公钥（服务器的公钥从步骤②中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。 ⑤ 如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的密钥一起传给服务器。 ⑥ 如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的 CA 是否可靠，发行 CA 的公钥能否正确解开客户证书的发行 CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的私钥，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。 ⑦ 服务器和客户端用相同的对称加密密钥，对称密钥用于 SSL 协议的安全数据通讯的加解密通讯。同时在 SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。 ⑧ 客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤 ⑦ 中的主密码为对称密钥，同时通知服务器客户端的握手过程结束。 ⑨ 服务器向客户端发出信息，指明后面的数据通讯将使用的步骤 ⑦ 中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。 ⑩ SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。 上述的过程需要弄懂的核心思想 客户端解析证书 这部分工作是由客户端的 TLS 来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个对称加密密钥，然后用公钥对该密钥进行非对称加密。 传送加密信息 这部分传送的是用公钥加密后的对称加密密钥，目的就是让服务端得到这个密钥，以后客户端和服务端的通信就可以通过这个密钥来进行加密解密了。 服务端解密信息 服务端用非对称加密算法里的私钥解密后，得到了客户端传过来的对称加密算法的私钥，然后把之后传输的内容通过该值进行对称加密。 为什么用非对称加密协商对称加密密钥 对称加密的特点：对称密码体制中只有一种密钥，并且是非公开的。如果要解密就得让对方知道密钥，所以想要保证其安全性就要保证密钥的安全。 非对称加密的特点：算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。非对称密钥体制有两种密钥，其中一个是公开的，这样就可以不需要像对称密码那样传输对方的密钥了，这样安全性就大了很多。 非对称加密公钥和私钥的使用方法：**(1) 公钥加密私钥解密。(2) 私钥做数字签名，公钥验证。** 补充： SSL 提供服务(1) 认证用户和服务器，确保数据发送到正确的客户机和服务器； (2) 加密数据以防止数据中途被窃取； (3) 维护数据的完整性，确保数据在传输过程中不被改变。 SSL 工作流程 服务器认证阶段： (1) 客户端向服务器发送一个开始信息 “Hello” 以便开始一个新的会话连接； (2) 服务器根据客户的信息确定是否需要生成新的主密钥，如需要则服务器在响应客户的 “Hello” 信息时将包含生成主密钥所需的信息； (3) 客户根据收到的服务器响应信息，产生一个主密钥，并用服务器的公开密钥加密后传给服务器； (4) 服务器回复该主密钥，并返回给客户一个用主密钥认证的信息，以此让客户认证服务器。 用户认证阶段：在此之前，服务器已经通过了客户认证，这一阶段主要完成对客户的认证。经认证的服务器发送一个提问给客户，客户则返回（数字）签名后的提问和其公开密钥，从而向服务器提供认证。 SSL 协议提供的安全通道有以下三个特性： 机密性：SSL 协议使用密钥加密通信数据。 可靠性：服务器和客户都会被认证，客户的认证是可选的。 完整性：SSL 协议会对传送的数据进行完整性检查。 服务器证书(server certificates)是 SSL 数字证书的一种形式，意指通过提交数字证书来证明您的身份或表明您有权访问在线服务。再者简单来说，通过使用服务器证书可为不同站点提供身份鉴定并保证该站点拥有高强度加密安全。是组成 Web 服务器的 SSL 安全功能的唯一的数字标识。通过相互信任的第三方组织获得，并为用户提供验证您 Web 站点身份的手段。服务器证书包含详细的身份验证信息，如服务器内容附属的组织、颁发证书的组织以及称为公开密钥的唯一的身份验证文件。 ———————————————— 版权声明：本文为CSDN博主「Tyler_Zx」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_38289815/article/details/80969419","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"https://hiro-lin.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"HTTP","slug":"HTTP","permalink":"https://hiro-lin.github.io/tags/HTTP/"},{"name":"HTTPS","slug":"HTTPS","permalink":"https://hiro-lin.github.io/tags/HTTPS/"}]}],"categories":[],"tags":[{"name":"lua","slug":"lua","permalink":"https://hiro-lin.github.io/tags/lua/"},{"name":"面试题","slug":"面试题","permalink":"https://hiro-lin.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"TCP","slug":"TCP","permalink":"https://hiro-lin.github.io/tags/TCP/"},{"name":"IP","slug":"IP","permalink":"https://hiro-lin.github.io/tags/IP/"},{"name":"UDP","slug":"UDP","permalink":"https://hiro-lin.github.io/tags/UDP/"},{"name":"HTTP","slug":"HTTP","permalink":"https://hiro-lin.github.io/tags/HTTP/"},{"name":"HTTPS","slug":"HTTPS","permalink":"https://hiro-lin.github.io/tags/HTTPS/"}]}